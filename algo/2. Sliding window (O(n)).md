Sliding window - это вариация паттерна Two Pointers. 
Обычно, в таких задачах нужно найти k-элементов, идущих по порядку. 
``k`` - это и есть размер нашего окна.  
Пока размер окна меньше `k` - сдвигаем указатель ``e(nd)``. 
Когда размер окна становится равен `k` - указатель `b(egin)` смещается вправо на 1. 
Так как на следующей итерации, ``e`` уже будет на 1 больше, то окно сужается в конце итерации.
``` 
 b     e       |      b     e     |        b     e
 I     I       |      I     I     |        I     I
[x, x, x, x, x] | [x, x, x, x, x] | [x, x, x, x, x]
```
# Шаблон
Нужно определиться с двумя условиями:
1. Что такое window_state в задаче? (обыч: аккумулятор в виде счетчика, хэшмапы и т.п.)
2. Какой shrink condition (условие поджима окна)? (обыч: дан по условию или подумать)
## С комментариями
```python
def task(nums):
	result = float('inf')         # переменная для складывания результата
	begin = 0                     # указатель начала окна
	window_state = 0              # хранит состояние окна(сумму элементов и т.п.)
	for end in range(len(nums)):  # указатель конца окна движется, тянет за собой
		window_state = ...        # операция с windows_state
		window_size = end-begin+1 # размер окна (end и begin - указатели, то +1)
		if/while window_size ... :# shrink condition (window_size > k и т.п.)
			result=...
			window_state=...
			begin += 1            # сужаем окно
	return result
```
## Чистый
```python
def task(nums):
	result = float('inf')      
	begin = 0         
	window_state = 0            
	for end in range(len(nums)):
		window_state = ...
		window_size = end-begin+1
		if/while window_size ... :
			result=...
			window_state=...
			begin += 1
	return result
```
# [643. Maximum Average Subarray I](https://leetcode.com/problems/maximum-average-subarray-i/)(O(n), O(1))
## Визуально
```  
window_state: сумма чисел внутри окна
shrink cond: когда размер окна == k

  |1 12 -5 -6 50 3|sum|  По условию, нужно найти подмассив длины k с максималь-
  |---------------|---|  ным средним. Чем больше сумма, тем больше среднее. 
1 |1 12 -5 -6     |  2|  Ставим указатели b и e на 0 индекс массива. Двигаем 
2 |  12 -5 -6 50  | 51|  указатель конца окна e в цикле: аккумулируем числа 
3 |     -5 -6 50 3| 42|  в window_state. Если на этой итерации размер окна 
                         равен k - в конце итерации нужно:
	                         1. положить result=max(result, window_state)
	                         2. отнять от windo2. tate значение под указателем b
	                         3.  увеличить b на 3.
	                     Возвращаем result / k.
```
## Код
```python
# window_state: сумма чисел внутри окна
# shrink cond: когда размер окна == k
class Solution:
    def findMaxAverage(self, nums: List[int], k: int) -> float:
        begin = 0
        window_state = 0
        result = float('-inf')
        for end in range(len(nums)):
            window_state += nums[end]
            window_size = end-begin+1
            
            if window_size == k:
                result = max(result, window_state)
                window_state -= nums[begin]
                begin += 1
        
        return result/k
```
# [209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/)(O(n), O(1))
## Визуально
```
window_state: cумма чисел внутри окна
shrink_cond: пока window_state >= target

 b                        Нужно найти минимальный размер подмассива, который  
[2,3,1,2,4,3] ws=8, t=7   даёт target. Идем в цикле, аккумулируем числа в 
       e                  windows_state. Как только window_state >= target, то
   b                      начинаем поджимать окно:
[2,3,1,2,4,3] ws=6, t=7      1. положить в result=min(result, window_size)
       e                     2. отнять от window_state знач. под b
   b                         3. увеличить b на 1
[2,3,1,2,4,3] ws=10, t=7  Если сумма чисел в исходном массиве меньше, чем
         e                в target, то окно никогда не подожмется и result не
     b                    изменится, проверь перед выходом из функции.
[2,3,1,2,4,3] ws=7, t=7
         e
       b                |        b                |          b
[2,3,1,2,4,3] ws=6, t=7 | [2,3,1,2,4,3] ws=9, t=7 | [2,3,1,2,4,3] ws=7, t=7
         e              |            e            |            e
```

## Код

```python
# window_state: cумма чисел внутри окна
# shrink_cond: пока window_state >= target
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        result = float('inf')
        begin = 0                     
        window_state = 0              
        for end in range(len(nums)):   
            window_state += nums[end] 
            
            while window_state >= target:
                window_size = end-begin+1 
                result=min(result, window_size)            
                window_state-=nums[begin]      
                begin += 1  
        
        if result == float('inf'):
            return 0          
        
        return result
```
# [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/)(O(n), O(1))
## Визуально
```
Идем в цикле и увеличиваем окно, считаем количество нулей в window_state. 
Наc устраивает окно, в котором всегда только k нулей. 
Если нулей стало больше - нужно нормализовать окно: 
	1. отнять от window_state один
	2. подвинуть begin на 1 вправо. 
После нормализации, мы записываем в результат максимальный размер окна 
между этой и предыдущей итерацией: result = max(result, window_size)
 b
[1,1,1,0,0,0,1,1,1,1,0], k = 2, result = max(0,5) = 5 
         e
   b
[1,1,1,0,0,0,1,1,1,1,0], k = 2, result = max(5,5) = 5
           e
     b
[1,1,1,0,0,0,1,1,1,1,0], k = 2, result = max(5,4) = 5
           e
         b
[1,1,1,0,0,0,1,1,1,1,0], k = 2, result = max(5,2) = 5
           e
           b
[1,1,1,0,0,0,1,1,1,1,0], k = 2, result = max(5,6) = 6
                     e
```
## Код
```python
# window_state: количество нулей в окне
# shrink_cond: когда window_state > k (в окне больше k нулей)
class Solution:
    def longestOnes(self, nums: List[int], k: int) -> int:
        begin = 0
        result = 0          
        window_state = 0 # how many zeroes           
        
        for end in range(len(nums)):
            if nums[end] == 0:
                window_state += 1
            
            # normalize window to have only 2 zeroes
            while window_state > k:
                if nums[begin] == 0:
                    window_state -= 1
                begin += 1
            
            window_size = end-begin+1
            result=max(result, window_size)
        
        return result
```
# [1493. Longest Subarray of 1's After Deleting One Element](https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/)(O(n), O(1))
## Визуально
Копия задачи 1004, только:
```
1. k = 1
2. return result - 1 (по условию, один элемент удаляется)
```
## Код
```python
class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        k = 1
        begin = 0
        result = 0          
        window_state = 0 # how many zeroes           
        
        for end in range(len(nums)):
            if nums[end] == 0:
                window_state += 1
            
            while window_state > k:
                if nums[begin] == 0:
                    window_state -= 1
                begin += 1
            
            result=max(result, end-begin+1)
        
        return result-1
```
# [904. Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/) (O(n), O(1))
## Визуально
```
         b                 |     b              |     b
fruits: [1, 2, 3, 2, 2]    | [1, 2, 3, 2, 2]    | [1, 2, 3, 2, 2]
            e              |        e           |              e
window_state: {1: 1, 2: 1} | {~1: 1~, 2:1, 3:1} | {2:3, 3:1}

По условию, в корзине (хэшмапе) может лежать только 2 различных типа фруктов (ключа). window_state - хэшмапа с ключами.
Идем в цикле и инкрементим для каждого ключа в хэшмапе. Как только её длина
становится больше 2, мы начинаем выбрасывать фрукты из начала:
	1. window_state[fruits[begin]] -=1
	2. если кол-во фруктов этого типа(по индексу begin) == 0 -> удаляем ключ
	3. сдвигаем begin на 1 вправо
После нормализации, в хэшмапе всего 2 ключа, в результат записываем 
максимальный размер окна: result=max(result, window_size)
```
## Код
```python
# window_state: словарь  с типами фруктов 
# shrink cond: когда len(window_state) > 2
class Solution:
    def totalFruit(self, fruits: List[int]) -> int:
        begin = 0
        window_state = defaultdict(int)
        result = 0
        for end in range(len(fruits)):
            window_state[fruits[end]]+=1

            while len(window_state) > 2:
                window_state[fruits[begin]] -= 1
                if window_state[fruits[begin]] == 0:
                    del(window_state[fruits[begin]])
                begin +=1
            window_size = end-begin+1
            result = max(result, window_size)
        return result
```
# [121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)(O(n),  O(1))
### Визуально
```
window_state: разница между prices[end] и prices[begin]
shrink сond: prices[end]<=prices[begin]

9|         |  Нужно получить максимальную выгоду между begin и end. В цикле,
7|     |   |  окно расширяется пока prices[end] > prices[begin]. Считаем профит 
5|   | |   |  на этом дне, максимальное записываем в result. Если цена упадет 
1| | | | | |  ниже или на тот же уровень prices[begin] - сжимаем окно до  
 -----------  prices[end], потенциально можем получить больший профит.
   b   e      
```
### Код
1. Ставим slow указатель на 0 позицию массива, fast на 1
2. Максимальный профит = 0
3. Fast указатель идет в цикле по массиву и сравниваем
4. Если prices.slow < prices.fast - то считаем новый профит, записываем масимальный между новым и страрым
5. Иначе, если prices.slow >= prices.fast - ставим slow на место fast
6. Возвращаем максимальный профит.
```python
# window_state: профит между end и begin
# shrink_cond: prices[end]<=prices[begin]
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        begin = 0
        window_state = 0
        result = 0
        for end in range(len(prices)):
            if prices[end] <= prices[begin]:
                begin=end
                continue
            
            window_state = prices[end]-prices[begin]
            result = max(result, window_state)
        
        return result
```
# [567. Permutation in String](https://leetcode.com/problems/permutation-in-string/) (O(n+m), O(1))
## Визуально
```
window_state(window_freq): частота вхождений символов в окне
shrink cond: если размер окна больше длины s1

Чтобы сравнить все перестановки s1 в s2, воспользуемся частотным анализом:
Так как строки содержат только англ. символы в нижнем регистре - всего их 26шт:
	1. создадим массив s1_freq на 26 элементов, заполним нулями
	2. пройдемся по s1 и для каждого элемента найдем его индекс в алфавите,
	   т.е. каждый элемент массива будет показывать сколько раз этот символ
	   встречался в строке s1: "aabccc" => [2,1,3,0,...,0]

Длина окна всегда будет равна длине s1. Мы точно уверены, что символы стоят рядом, а их порядок нам не важен. 
window_state будет аналогичен s1_freq, только хранить вхождения символов из s2.

w_f=[b:1, e:1, i:1]  Начало окна на 0 индекс, конец двигаем в цикле по длине s2. 
s2="eidbaooo"        Если длина окна стала больше длины s1 - сжимаем:
    b                  1. находим позицию символа под индексом b в w_f и -=1:
      e                   1.1. s2[b] = 'e'
[d:1, e:0, i:1]           1.2. ord(s2[b]) = 101
"eidbaooo"                1.3. ord(s2[b]) - ord('a') = 4
  b                       1.4. w_f[ord(s2[begin]) - ord('a')] => wf_f[4]=-1
   e                   2. Cдвигаем указатель b вправо на 1
[b:1, d:1, e:0, i:0]    
"eidbaooo"           После нормализации размера окна, в window_freq добавляем +1
   b                 для символа на индексе е (конце окна).
    e 
[a:1, b:1, d:0, e:0, i:0]  Если window_freq == s1_freq, те все символы из s1
"eidbaooo"                 присутствуют в окне - возвращаем True. После выхода из
    b                      цикла возвращаем Fasle, если ни одной перестановки не
     e                     найдено.
```
## Код
```python
# window_state(window_freq): актуальные символы в окне
# shrink cond: когда размер окна больше длины s1
class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        if len(s1) > len(s2):
            return False
        
        offset = ord('a')
        s1_freq = [0]*26
        window_freq = [0]*26
        # ord('a') = 97
        # s1[i] = 'a'
        # ord(s1[i]) - ord('a') = 0
        for i in range(len(s1)):
            s1_freq[ord(s1[i])-offset]+=1
        
        begin = 0
        for end in range(len(s2)):
            window_size = end-begin+1
            # normalize window size
            if window_size > len(s1):
                window_freq[ord(s2[begin])-offset] -=1 
                begin+=1
            
            window_freq[ord(s2[end])-offset] +=1
            
            if s1_freq == window_freq:
                return True
        
        return False
```
