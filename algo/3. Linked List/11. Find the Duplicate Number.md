#algos 
#algos/03linkedlist

# [287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)
?
## Сложность
* Time: O(n)
* Space: O(1)
## Визуально
```
Дан массив из n+1 элементов, в котором лежат значения [1, n]. 
Иными словами, в массиве лежат уникальные значения, но одно из них 
повторяется 2 раза. Найти повторяющийся элемент.

элементы:|1|3|4|2|2| |   0->3->2->4+   Идея: такой массив можно представить
индексы : 0 1 2 3 4  |=>       ^   |   в виде связного списка, с началом на
                     |         |---+   0 индексе массива, где: 
						                  * индекс  - значение ноды 
										  * элемент - указатель на след. ноду

После трансформации, видим образовавшийся цикл в списке. 
Задача сводится к поиску элемента, на котором начинается цикл.
Используем алгоритм Флойда для поиска цикла в связном списке.

0->|3->2->4+|  Заметим, что первая нода (0) не является частью цикла,
   |   ^   ||  так как в изначальном массиве лежат числа [1, n].
   |   |---+|  На ноду 2 указывают две других ноды - 3 и 4.
   ----------  
Теорема: Расстояние между началом списка и искомой нодой равно 
расстоянию между нодой, где slow и fast указатели перескаются в 
первый раз и искомой нодой. Доказательство приведено ниже.

Алгоритм решения:
	1. Ставим slow1 и fast на 0 индекс массива.
	2. Используя алгоритм Флойда, ищем элемент, 
	   на котором slow1 и fast пересекутся:
		2.1. slow1 = nums[slow1] (элемент - указатель на новую ноду)
		2.2. fast = nums[nums[fast]] (прыгает 2 раза)
		2.3. if nums[slow1] == nums[fast], то выходим из цикла
	3. Ставим slow2 на 0 индекс.
	4. Двигаем slow1 и slow2 на 1, пока они не встретятся.
	5. Если встретились - выходим из цикла, возвращаем slow1.
```
## Доказательство
```
  p            Обозначим расстояние между 0 и 1 за p, между 5 и 1 за x.
0->1->2->3-+   0 и 5 - это две ноды, которые указывают на начало цикла.
s1 ^       |С  Длина цикла C равна 5. Расстояние между 1 и 5 по часовой:
f  |x      |            d(1,5) = C - x
   +-5<-4<-+   Так как slow движется в 2 раза медленнее fast, 
               fast пройдет расстояние p, полный цикл С и еще C - x,
			   перед тем, как slow и fast встретятся:
                    |  2*slow1 = fast    |
				    | 2(p+C-x) = p+C+C-x |
					| 2p+2C-2x = p+2C-x  |
					|      p-x = 0       |
					|	     p = x       |
После встречи slow1 и fast, поставим указатель slow2 на начало списка.
Когда slow1 и slow2 указатели встретятся - они будут указывать 
на начало цикла в списке, так как пройдут одинаковое расстояние.

В общем случае, расстояние p может быть равно N. 
Тогда fast указателю придется пройти цикл несколько раз, но, 
в конечном итоге, slow1 и fast встретятся за N шагов до начала цикла.
```
## Код
```python
# MVCD:
# 1. Use Floyd's Tortoise and Hare cycle detection.
# 2. First, find intersection point.
# 3. Then put slow2 pointer to head.
# 4. Move both slow pointes until they meet.
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
		# Pt1: find fast and slow1 intersection
        slow1, fast = 0,0
        while True:
            slow1 = nums[slow1]
            fast = nums[nums[fast]]
            if nums[slow1] == nums[fast]:
                break
        # Pt2: move slow1 and slow2 until they meet
        slow2 = 0
        while True:
            slow1 = nums[slow1]
            slow2 = nums[slow2]
            if slow1 == slow2:
                break
        
        return slow1
```
<!--SR:!2025-07-05,3,250-->