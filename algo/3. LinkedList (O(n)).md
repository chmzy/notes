**Linked List** - коллекция, представляющая связный список. В отличии от массива, элементы Linked List разбросаны по памяти и не обязательно лежат рядом. Каждый элемент состоит из 2х полей - значение и указатель на следующий элемент:
```
head+   +------+   +------+   +tail
    |   |      |   |      |   |
  +-v-+-+-+  +-v-+-+-+  +-v-+-v-+  
  |   |   |  |   |   |  |   |   |  
  | 2 |ptr|  | 5 |ptr|  | 8 |nul|  
  |   |   |  |   |   |  |   |ptr|  
  +---+---+  +---+---+  +---+---+  
    Node1      Node2      Node3    
```
**Head** - начало linked list, голова. Может быть первым элементов, может быть заглушкой.
**Tail** - конец linked list. Может быть последним элементов, может быть заглушкой.

В задачах на Linked List нам дан только первый элемент - Head. Все операции начинаются с неё. Давайте реализуем эту коллекцию для лучшего понимания.
# [707. Design Linked List](https://leetcode.com/problems/design-linked-list/)
```go
type Node struct {
	Val  int
	Next *Node
}

type MyLinkedList struct {
	Head *Node
    Len int
}

func Constructor() MyLinkedList {
	return MyLinkedList{}
}

func (this *MyLinkedList) Get(index int) int {
	if index < 0 || index >= this.Len{
        return -1
    } 
    
    current := this.Head
	for i:=0; i<index; i++ {
		current = current.Next
	}
	return current.Val
}

func (this *MyLinkedList) AddAtHead(val int) {
    this.AddAtIndex(0, val)
}

func (this *MyLinkedList) AddAtTail(val int) {
    this.AddAtIndex(this.Len, val)
}

func (this *MyLinkedList) AddAtIndex(index int, val int) {
    if index < 0 || index > this.Len{
        return
    }
    this.Len+=1;

    if index == 0{
        newNode := &Node{Val: val, Next: this.Head}
        this.Head = newNode
        return
    }
	
    current := this.Head
    for i:=0; i<index-1;i++{
        current = current.Next
    }
	
	current.Next = &Node{Val: val, Next: current.Next}
}

func (this *MyLinkedList) DeleteAtIndex(index int) {
    if index < 0 || index >= this.Len{
        return
    } 
    this.Len -=1
    if index == 0{
        this.Head = this.Head.Next
        return
    }
    current := this.Head
    for i:=0; i<index-1;i++{
        current = current.Next
    }
    current.Next = current.Next.Next
}
```
# [876. Middle of the Linked List](https://leetcode.com/problems/middle-of-the-linked-list/)(O(N), O(1))
## Визуально
```
Найти середину связного списка.
Ставим 2 указателя на голову списка. Если fast указатель будет двигваться 2 раза быстрее, чем slow, то к моменту достижения fast конца списка - slow будет указывать на его середину.
Пока существует fast и fast.next (если текущий и следующий от fast элементы не null), двигаем fast и slow. При нечетной длине списка, fast будет указывать на последний элемент, при четной - на null. Поэтому нужна проверка while fast, чтобы остановиться.

Четная длина:
5->6->7->10->null| 5->6->7->10->null | 5->6->7->10->null
s                |    s              |       s
f                |       f           |              f

Нечетная длина:
5->6->7->null| 5->6->7->null |
s            |    s          |
f            |       f       |
```
## Код
```python
class Solution(object):
    def middleNode(self, head):
        fast = head
        slow = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
        return slow
```
# [2095. Delete the Middle Node of a Linked List](https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/)(O(n), O(1))
## Визуально
```
Удалить элемент из середины списка.
Если перед началом движения дать fast фору в 2 элемента, то к моменту когда он окажется в конце - slow будет стоять перед срединным элементом.
Переназначаем slow.next = slow.next.next

Четная длина:
5->6->7->10->null| 5->6->7->10->null |
s                |    s              |
      f          |               f   |

Нечетная длина:
5->6->7->null| 
s            |
     f       |

```
## Код
```python
class Solution(object):
    def deleteMiddle(self, head):
        if not head.next:
            return None
        
        slow = head
        fast = head.next.next

        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
        slow.next = slow.next.next
        return head
```

# [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)(O(n), O(1))
## Визуально
```
1->2->3->4->None       Развернуть связный список. 

p                      Чтобы сохранить связи, используем 2 указателя:
1->2->3->4->None  	      1. prev(p)    на предыдущий элемент
   c			          2. current(c) на текущий элемент
                       
 p                     Голова списка станет хвостом,
None 1->2->3->4->None  поэтому она должна будет указывать на None:
     c               	   1. prev(p)    = None
                           2. current(c) = head
                       
 p       t              Алгоритм разворачивания:
None  1->2->3->4->None	   1. tmp = curr.next (для сохранения связи) 
	  c 				   2. curr.next = prev (меняем направление curr)
 p	     t 	 		       3. prev = curr (двигаем prev на место curr)
None<-1  2->3->4->None	   4. сurr=tmp (двигаем curr дальше) 
      c                 В конце, prev будет указывать на новый head списка.	  
	  p     t          |     |                   c
None<-1  2->3->4->None | ... | None<-1<-2<-3<-4 None
         c             |     |                p
```
## Код
```python
class Solution(object):
    def reverseList(self, head):
        prev = None
        current = head
        while current:
            tmp = current.next
            current.next = prev
            prev = current
            current = tmp
        return prev
```
# [234. Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/)(O(n), O(1)))
## Визуально
Решение использует логику `876. Middle of the LL` и `206. Reverse LL`
```
1->2->2->1->N  Является ли список палиндромом.
               Для решения задачи, нужно:
				   1. Дойти до середины списка
				   2. Развернуть вторую половину
				   3. Сравнить 2 списка через 2 указателя
1->2->2<-1  После разворачивания списка с середины, он примет вид слева.
      V     Элемент 1го до середины все еще будет ссылаться на один из элементов
	  N     2го списка, но второй уже будет указывать на другой конец.

1->2->2<-1  reverseList() вернет указатель на голову второго списка. Это и есть
f	  V	 s	второй(s) указатель. Первый указатель(f) - на head исходного списка.
      N     Пока first и second не NULL, сравниваем значения, двигаем на next.
	        Когда second дойдет до NULL, значит дошли до конца и выйдем из цикла.
```
## Код
```python
class Solution(object):
    def middleNode(self, head):
        fast = head
        slow = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
        return slow
    def reverseList(self, head):
        prev = None
        current = head
        while current:
            tmp = current.next
            current.next = prev
            prev = current
            current = tmp
        return prev
    def isPalindrome(self, head):
        mid = self.middleNode(head)    # O(n)
        second = self.reverseList(mid) # O(n)
        first = head
        while first and second:        # O(n)
            if first.val != second.val:
                return False
            first = first.next
            second = second.next
        return True  
```
# [83. Remove Duplicates from Sorted List](https://leetcode.com/problems/remove-duplicates-from-sorted-list/)(O(n), O(1))
## Визуально
```
1->1->1->2->3->None  Убрать все дубликаты из списка.
c  cn                Ставим current на head. 
					 Пока current и current.next существуют (не None), 
					 сравниваем:
1->1->2->3->None	     1. c.val == c.next.val -> c.next = c.next.next, 
c  cn						те удаляем current.next
						 2. c.val != c.next.val -> c = c.next, двигаем current
 1->2->3->None      Возвращаем head.
 c  c.n
```                  
## Код
```python
class Solution(object):
    def deleteDuplicates(self, head):
        current = head
        while current and current.next:
            if current.val == current.next.val:
                current.next = current.next.next
            else:
                current = current.next
        return head
```
# [19. Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)(O(n), O(1), single pass)
## Визуально
```
1->2->3->(4)->5->None  Удалить Nый элемент списка с конца. За 1 проход.
     
					   Идея: нужно дать f указателю фору в N шагов. 
1->2->3->(4)->5->None  Далее, пока f != None, двигаем s и f на 1 шаг вперед.
s     f       		   Когда f дойдет до конца, s будет за N шагов до него - 
	                   перед тем элементом, который нужно удалить.
1->2->3->(4)->5->None  Дошли, удаляем: s.next = s.next.next
      s       f                     
                       Но по усл, список может содержать только 1 элемент.
d->1->2->3->(4)->5->N  Чтобы легко удалить голову, вставим элемент-заглушку - 
s        f             dummy node (d) - которая будет ссылаться на head списка.
					   Даем фору на N+1 шагов из-за этого.
                       
					   В конце возвращаем dummy.next (изначальный head).
```
## Код
```python
class Solution(object):
    def removeNthFromEnd(self, head, n):
        dummy = ListNode()
        dummy.next = head

        slow = dummy
        fast = dummy
        for _ in range(n+1):
            fast = fast.next
        
        while fast:
            fast =  fast.next
            slow = slow.next
          
        slow.next = slow.next.next
        
        return dummy.next
```
# [24. Swap Nodes in Pairs](https://leetcode.com/problems/swap-nodes-in-pairs/) (O(n), O(1))
## Визуально
```
1->2->3->4->N     Перевернуть список парами.
2->1->4->3->N     Так как голова может инвалидироваться, ставим dummy перед ней. 
                  Ставим указатель current на dummy.
c  f  s           Пока существует c.next и c.next.next, делаем действия:
d->1->2->3->4->N     1. first,second = c.next, c.next.next
c  s  f              2. f.next = second.next 
d->2->1->3->4->N     3. second.next = first
      c  f  s        4. current.next = second
d->2->1->3->4->N	 5. current = first
                  Возвращаем dummy.next.
```
## Код
```python
class Solution(object):
    def swapPairs(self, head):
        dummy = ListNode()
        dummy.next = head
        current = dummy
        while current.next and current.next.next:
            first = current.next
            second = current.next.next
            
            first.next = second.next
            second.next = first
            current.next = second
            
            current = first
        return dummy.next
```
# [21. Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/) (O(n), O(1))
## Визуально
```
1->2->4->N           Соединить 2 отсортированных списка. Без доп. памяти.
1->3->4->N           
1->1->2->3->4->4->N     
-------------
  p1
  1->2->4->N         Так как мы не знаем какой элемент станет головой списка,
d                    ставим dummy node, current указатель ставим на неё.
с 1->3->4->N         Указатель p1 ставим на head l1, p2 - l2. Пока существуют
  p2                 p1 И p2. Так как мы идем с начала списка, то и значения
-------------         должны записывать в возрастающем порядке - берем меньшее:
   p1	                1. Если p1.val < p2.val, то c.next = p1, p1 = p1.next
   1->2->4->N 	        2. Иначе: c.next = p2, p2 = p2.next

d->1->3->4->N        Может получиться так, что все элементы из l1 меньше, чем
   c  p2             в l2 (1-2-3 и 4-5-6). И после основного цикла, p1 или p2
-------------        все еще будет ссылаться на валидный элемент одного
   c  p1             из списков. 
   1->2->4->N        Нужно пришить оставщуюся часть одним действием:
   ^                    1. Если p1 != None: current.next = p1
d->1  3->4->N           2. Если p2 != None: сurrent.next = p2
      p2             Возвращаем dummy.next
```
## Код
```python
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode()
        current = dummy

        p1 = list1
        p2 = list2
        while p1 and p2:
            if p1.val < p2.val:
                current.next = p1
                p1 = p1.next
            else:
                current.next = p2
                p2 = p2.next
            current = current.next
        
        if p1:
            current.next = p1
        if p2:
            current.next = p2
            
        return dummy.next
```
# [141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)(O(n), O(1))
## Визуально
```
3->2->0->4  Ответить если ли цикл в списке, без доп. памяти.
   ^-----+

Нужно использовать алгоритм Флойда (Зайца и Черепахи).
Это доказанный алгоритм поиска циклов в связном списке. 
Второй указатель движется в 2 раза быстрее, чем первый. 
В конечном итоге, второй всегда догонит первый.

Ставим указатели s и f на head. 
Пока f и f.next существуют (f дошел до конца списка):
	1. s=s.next
	2. f=f.next.next
	3. Так как значения s и f могут быть равны у разных элементов,
	сравниваем адреса s == f. Равны - нашли цикл, возвращаем True
Если мы вышли из while - то цикла нет. Возвращаем False.
```
## Код
```python
class Solution(object):
    def hasCycle(self, head):
        s = head
        f = head
        while f and f.next:
            s = s.next
            f = f.next.next
            if s == f:
                return True
        return False
```

# [287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)
## Визуально
```

```
## Код
```python

```
# [143. Reorder List](https://leetcode.com/problems/reorder-list/)
## Визуально
```

```
## Код
```python

```

# [138. Copy List with Random Pointer](https://leetcode.com/problems/copy-list-with-random-pointer/)
## Визуально
```

```
## Код
```python

```
# [2. Add Two Numbers](https://leetcode.com/problems/add-two-numbers/)
## Визуально
```

```
## Код
```python

```